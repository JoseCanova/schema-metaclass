Version 0.1 (of the READ.ME) file.

Purpose of the project.

On a previous exercise which was achieved, the main objective is to construct
a small library that should be capable to build the mapping (at first glance)
using Object Relational Mapping based on a Relational Schema

At first it should be prepared a "base data structure" that must be populated with
the relational information to mount the ORM model intended of be the mapping between
the serialized structured in the relational database and the object (im memory) model,
for such purpose it's being used as a source of information
an open source library instead of JDBC directly named schema-crawler.

The reason of adoption of schema crawler is the data abstraction over specific relational
databases. Since the RDBMS and SQL dialect differ from database to database.

Rationale: 


The reason of an "autonomous ORM" mapping, it's the understanding of some simple assumptions.

1- Regarding the project it self ? If its continues feasible to mount a ORM mapping (since on previous spring versions a simple autonomous mapping worked)
based on a autonomous orm mapping build strategy (which means expose the model as an ORM mapping before 
the formalization of the ORM mapping it self).

2- Regarding the technology : A proof of concept and a path to understand the "impedance mismatch" between ORM<->RDBMS, which means:
what are the "impeditive" actions that lead a non-adoption of an autonomous ORM mapping or a manual implementation of the ORM mapping.
 
3- Continue the understanding of autonomous ORM-Mapping which on practice could be proved of some utility
to analyze the difference of Object Mapping (the relation of objects) and "relational mapping" (which means what
tables aren`t used to describe objects does it makes any sense?). 
 
 Future usage of the library!
 
 1 - ORM frameworks provide a normalized dialect between relational databases (for example hibernate provides HQL).
 
 2- A tool for HQL injection, using the "best practices". which mean an interface to verify hql queries against the generated model.
 
 3- Verify the different on-tomany strategies provided by the ORM mapping and which is the best use of the mapping (on to many) strategy
 given the rdbms strategy.
 
 Next Steps
 
 1- Decompose the library into more "subcomponents". actually there are "many responsibilities" on the current project,
 It`s quite interesting decompose some "internal design" into separate modules enumerating 2. 
 1.1 - Check the feasibility to move "bean creating" that is parameterized from "metaclasses" to a separate project,.
 It will be a difficult task since the "object construction" upon metaclasses (on practice when serialized a json object).
 1.2 - Move the "table classification" tasks to a separate project. 
 Rationale: Understand that "provide a classification" of the tables in the database it`s a "alternate concern", 
 it will be handy for "ORM class specialization" to understand how the database model is normalized (which level of normalization 
 each table achieved), since full normalization it`s not a common practice not that the "model is wrong" but main means that the 
 entire database model has not achieved full normalization model. 
 
 2- Generate a "spring-boot-starter" project for the library. 
 2.1- It will be interesting to provide a spring boot starter project for this project which will facilitate the usage
 of the library. There are several issues ahead that need to be thought, but it will be an interesting alternative.
 
 15-01-2024
 ---- First step : refactor which means move to other subproject the "normal forms classification" because is a complex matter.
 adopting the KISS principle, this project is merely a mapping (and bean construction) between schema-crawler and metaclass
 (this is the name adopted) and a prototype of bean configuration, probably bean configuration will be "turned into another" subproject
 mainly to first simplify the project steps and adopt a microservice archtecture.
 
